{
  "history": [
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "gradient",
      "usesPingPong": false,
      "speed": 0.25,
      "trackMouse": 0,
      "mouseMomentum": 0,
      "texture": false,
      "animating": false,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos;vec3 getColor(int index) { switch(index) { case 0: return vec3(0.9333333333333333, 0.9333333333333333, 0.9333333333333333); case 1: return vec3(0, 0, 0); case 2: return vec3(0, 0, 0); case 3: return vec3(0, 0, 0); case 4: return vec3(0, 0, 0); case 5: return vec3(0, 0, 0); case 6: return vec3(0, 0, 0); case 7: return vec3(0, 0, 0); case 8: return vec3(0, 0, 0); case 9: return vec3(0, 0, 0); case 10: return vec3(0, 0, 0); case 11: return vec3(0, 0, 0); case 12: return vec3(0, 0, 0); case 13: return vec3(0, 0, 0); case 14: return vec3(0, 0, 0); case 15: return vec3(0, 0, 0); default: return vec3(0.0); } }const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) { float s = sin(angle); float c = cos(angle); return vec2( coord.x * c - coord.y * s, coord.x * s + coord.y * c ); }out vec4 fragColor;vec3 getColor(vec2 uv) {return vec3(0.9333333333333333, 0.9333333333333333, 0.9333333333333333); }void main() {vec2 uv = vTextureCoord; vec2 pos = vec2(0.8035908596300327, 0.48084874863982585) + mix(vec2(0), (uMousePos-0.5), 0.0000); uv -= pos; uv /= (0.5000*2.); uv = rotate(uv, (0.0000 - 0.5) * 2. * PI); vec4 color = vec4(getColor(uv), 1.); fragColor = color; }"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"
      ],
      "data": {
        "downSample": 0.5,
        "depth": false,
        "uniforms": {},
        "isBackground": true
      },
      "id": "effect"
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "texturize",
      "usesPingPong": false,
      "speed": 0.24,
      "texture": false,
      "parentLayer": "8479c7f3-d927-4427-945b-21d26758119b",
      "animating": true,
      "mouseMomentum": 0,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime;uint fibonacciHash(uint x) { const uint FIB_HASH = 2654435769u; uint hash = x * FIB_HASH; hash ^= hash >> 16; hash *= 0x85ebca6bu; hash ^= hash >> 13; hash *= 0xc2b2ae35u; hash ^= hash >> 16; return hash; }float randFibo(vec2 xy) { uint x_bits = floatBitsToUint(xy.x); uint y_bits = floatBitsToUint(xy.y); uint y_hash = fibonacciHash(y_bits); uint x_xor_y = x_bits ^ y_hash; uint final_hash = fibonacciHash(x_xor_y); return float(final_hash) / float(0xffffffffu); } out vec4 fragColor;void main() { vec2 uv = vTextureCoord; float timeRand1 = randFibo(vec2(floor(uTime * 0.5) * 2. + 0.001, 0.5)); float timeRand2 = randFibo(vec2(floor(uTime * 0.5) * 2. + 1.001, 0.5)); float sizeX = 0.5000 * 0.2 * timeRand1; float sizeY = 0.5000 * 0.2 * timeRand2; float floorY = floor(uv.y/sizeY) + 0.005; float floorX = floor(uv.x/sizeX) + 0.005; float phase = 0.0000 * 0.01; float chromab = 0.5000 * 0.75; float offset = 0.;vec2 blockSize = vec2(50.0, 50.0) * (1.0 - 0.5000); vec2 blockUV = floor(uv * blockSize) / blockSize; float blockRand = randFibo(blockUV); float blockTimeRand = timeRand1; float blockNoise = mix( 1., step(0.8, randFibo(vec2(blockTimeRand, blockRand))), 0.8000 );float offsetX = 0.5000 * 0.5 * blockNoise; float offsetY = 0.0000 * 0.5 * blockNoise;float randY = randFibo(vec2(sin(floorY + offset + phase), 0.5)); float randX = randFibo(vec2(cos(floorX + offset + phase), 0.5)); float glitchModX = max(0.005, sign(randY - 0.5 - (1. - 0.5000*2.)/2.)); float glitchModY = max(0.005, sign(randX - 0.5 - (1. - 0.5000*2.)/2.));float randOffX = randFibo(vec2(floorY + offset * glitchModX + phase, 0.7)); float randOffY = randFibo(vec2(floorX + offset * glitchModY + phase, 0.9)); float offX = (randOffX * offsetX - offsetX/2.)/5.; float offY = (randOffY * offsetY - offsetY/2.)/5.;offX = clamp(offX, -1.0, 1.0); offY = clamp(offY, -1.0, 1.0);uv.x = mix(uv.x, uv.x + offX * 2., glitchModX); uv.y = mix(uv.y, uv.y + offY * 2., glitchModY);float waveFreq = 30.0; float waveAmp = 0.005 * 0.2000; float timeOffset = uTime * 0.05; float sinY = sin((uv.y + 0.0000) * waveFreq * (1. - 0.5000) * 2. + timeOffset); float rogue = smoothstep(0., 2., sinY - 0.5) * 0.2 * 0.2000; float sinWaveX = sin(uv.y * waveFreq + uTime); float sinWaveY = sin(uv.x * waveFreq + uTime); uv.x += sinWaveX * waveAmp + rogue; uv.y += sinWaveY * waveAmp; float waveX = sinWaveX * waveAmp + rogue * chromab * 0.2;uv = clamp(uv, vec2(0.005), vec2(0.995));vec4 color = texture(uTexture, uv);vec2 redOffset = vec2( clamp(uv.x + (glitchModX * -offX * chromab - waveX), 0.005, 0.995), clamp(uv.y + (glitchModX * -offY * chromab), 0.005, 0.995) ); vec2 blueOffset = vec2( clamp(uv.x + (glitchModX * offX * chromab + waveX), 0.005, 0.995), clamp(uv.y + (glitchModX * offY * chromab), 0.005, 0.995) );color.r = texture(uTexture, redOffset).r; color.b = texture(uTexture, blueOffset).b; fragColor = color;}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "depth": false, "uniforms": {}, "isBackground": false },
      "id": "effect1"
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "mouse",
      "usesPingPong": true,
      "mouseMomentum": 0,
      "texture": false,
      "parentLayer": "985bcfe6-97d1-4531-b452-7b4d87e26238",
      "animating": false,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float;in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uTexture; uniform sampler2D uPingPongTexture; uniform vec2 uResolution;const float PI = 3.1415926; const float ITERATIONS = 24.0;out vec4 fragColor;vec3 rgb2hsv(vec3 c) { vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g)); vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y); float e = 1.0e-10; return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); }vec3 chromatic_aberration(vec3 color, vec2 uv, vec2 offset) { vec4 left = texture(uTexture, uv - offset); vec4 right = texture(uTexture, uv + offset);color.r = left.r; color.b = right.b;return color; }vec2 pixelate(vec2 uv) { float aspectRatio = uResolution.x / uResolution.y; float scale = 0.5000 / 2.0; vec2 modulate = mod(vec2(uv.x * aspectRatio, uv.y) - 0.5, (scale + 0.01) / 12.0); return vec2( uv.x - modulate.x / aspectRatio + (0.08333 * scale) / 2.0, uv.y - modulate.y + (0.08333 * scale) / 2.0 ); }vec2 angleToDir(float angle) { float rad = angle * 2.0 * PI; return vec2(cos(rad), sin(rad)); }vec4 pixelTrail(vec2 uv, vec2 mouseDir, float strength) { vec4 color = vec4(0); vec2 distorted = mouseDir * 0.4; vec2 pixelated = uv - distorted; color = texture(uTexture, pixelated); color.rgb = chromatic_aberration(color.rgb, pixelated, distorted * 0.2500 * 0.12); return color; }vec4 getTrailColor(vec2 uv, vec2 mouseDir, float strength) { vec4 color = vec4(0); float aspectRatio = uResolution.x / uResolution.y;return pixelTrail(uv, mouseDir, strength); }void main() { vec2 uv = vTextureCoord; vec2 pingpongUv = uv;pingpongUv = pixelate(pingpongUv);vec3 mouseRgb = texture(uPingPongTexture, pingpongUv).rgb; vec3 mouseTrail = rgb2hsv(mouseRgb);float angle = mouseTrail.x; float strength = mouseTrail.z * (0.2000 * 2.0); vec2 direction = angleToDir(angle); vec2 mouseDir = direction * strength;vec4 color = getTrailColor(uv, mouseDir, strength);fragColor = color; }",
        "#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uPingPongTexture; uniform vec2 uPreviousMousePos;uniform vec2 uMousePos; uniform vec2 uResolution;const float PI = 3.1415926; const float TWOPI = 6.2831852;out vec4 fragColor;vec3 hsv2rgb(vec3 c) { vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www); return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); }void main() { float aspectRatio = uResolution.x / uResolution.y; vec2 uv = vTextureCoord; vec2 correctedUv = uv * vec2(aspectRatio, 1.0);vec2 dir = (uMousePos - uPreviousMousePos) * vec2(aspectRatio, 1.0); float dist = length(dir); dir = normalize(dir);float rad = 0.5000 * 0.4 * mix(aspectRatio, 1.0, 0.5); float angle = atan(dir.y, dir.x); if (angle < 0.0) angle += TWOPI;float distLine = distance(uPreviousMousePos, uMousePos);float t = clamp(dot(correctedUv - uPreviousMousePos * vec2(aspectRatio, 1.0), dir) / dist, 0.0, 1.0); vec2 closestPoint = mix(uPreviousMousePos, uMousePos, t) * vec2(aspectRatio, 1.0); float distanceToLine = distance(correctedUv, closestPoint);float s = smoothstep(rad, rad * 0.0000, distanceToLine);s = s * s;vec3 color = vec3(angle / TWOPI, 1.0, 1.0); vec3 mouseColor = hsv2rgb(color);vec2 sampleUv = mix(uv, uv / (1.0 + 0.0000 * 0.03) + 0.0000 * 0.015, 0.0000); vec3 lastFrameColor = texture(uPingPongTexture, sampleUv).rgb; lastFrameColor = pow(lastFrameColor, vec3(2.2)); mouseColor = pow(mouseColor, vec3(2.2)); float intensity = min(0.7, dist * 10.0) * s * 0.4; vec3 draw = mix(lastFrameColor, mouseColor, intensity); draw *= pow(0.5000, 0.2); draw = pow(draw, vec3(1.0/2.2)); fragColor = vec4(draw, 1.0); }"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }",
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"
      ],
      "data": { "depth": false, "uniforms": {}, "isBackground": false },
      "id": "effect2"
    },
    {
      "breakpoints": [
        {
          "props": { "fontStyle": "regular" },
          "min": 992,
          "max": null,
          "name": "Desktop"
        },
        {
          "min": 576,
          "name": "Tablet",
          "props": { "fontStyle": "regular" },
          "max": 991
        }
      ],
      "visible": true,
      "locked": false,
      "aspectRatio": 1,
      "layerName": "Hello",
      "userDownsample": 0.75,
      "isElement": true,
      "opacity": 1,
      "effects": ["985bcfe6-97d1-4531-b452-7b4d87e26238"],
      "displace": 0,
      "trackMouse": 0.12,
      "anchorPoint": "topLeft",
      "mouseMomentum": 0.08,
      "blendMode": "NORMAL",
      "bgDisplace": 0,
      "mask": 0,
      "maskBackground": { "type": "Vec3", "_x": 0, "_y": 0, "_z": 0 },
      "maskAlpha": 0,
      "maskDepth": 0,
      "dispersion": 0,
      "axisTilt": 0.12,
      "states": {
        "appear": [
          {
            "local": {
              "pendingChanges": {},
              "changeDebouncer": null,
              "dragSession": null
            },
            "type": "appear",
            "id": "afbc3491-8d55-4459-ac21-1dd3457120b4",
            "prop": "opacity",
            "transition": {
              "ease": "easeInOutQuart",
              "duration": 1000,
              "delay": 0
            },
            "complete": false,
            "progress": 0,
            "value": 1,
            "endValue": 1,
            "initialized": false,
            "breakpoints": ["Desktop", "Tablet", "Mobile"],
            "loop": "none",
            "loopDelay": 0,
            "uniformData": { "type": "1f", "name": "uOpacity" }
          }
        ],
        "scroll": [],
        "hover": []
      },
      "layerType": "text",
      "justCreated": false,
      "isSafari": false,
      "width": 1194,
      "widthMode": "fixed",
      "height": 288,
      "heightMode": "fixed",
      "left": 0.08541666666666664,
      "leftMode": "relative",
      "top": 0.08000000000000002,
      "topMode": "relative",
      "rotation": 0,
      "fontSize": 0.1,
      "lineHeight": 1,
      "letterSpacing": 0,
      "fontFamily": "Montagu Slab",
      "fontStyle": "regular",
      "fontWeight": "400",
      "textAlign": "left",
      "textContent": "Hello Company,\nIm Kelvin",
      "fill": ["#000000"],
      "gradientAngle": 0,
      "gradientType": "linear",
      "fontSizeMode": "relative",
      "fontCSS": {
        "family": "Montagu Slab",
        "src": "https://assets.unicorn.studio/fonts/google_fonts/6qLhKZIQtB_zv0xUaXRDWkY_HXsphdLRZF40vm_jzR2jhk_n3T6ACkDbEnP9Fs7bOSO7.ttf"
      },
      "compiledFragmentShaders": [
        "#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; uniform float uOpacity; uniform int uSampleBg;vec2 perspectiveUV(vec2 uv) { float aspectRatio = uResolution.x/uResolution.y; vec2 centeredUV = uv - 0.5; centeredUV.x *= aspectRatio; float strength = 1.0 + (vVertexPosition.z * 0.1200); vec2 perspectiveUV = centeredUV / strength; perspectiveUV.x /= aspectRatio; perspectiveUV += 0.5; return perspectiveUV; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.1200);uv = perspectiveUV(uv) - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color / max(color.a, 0.0001), color.a * uOpacity);fragColor = color; }"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "uniforms": {} },
      "id": "text",
      "windowWidth": 1440
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 0.75,
      "layerType": "effect",
      "type": "texturize",
      "usesPingPong": false,
      "speed": 0.24,
      "texture": false,
      "parentLayer": "c12993ab-36f5-49fe-8cb0-6e2b7c9657ee",
      "animating": true,
      "mouseMomentum": 0,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime;uint fibonacciHash(uint x) { const uint FIB_HASH = 2654435769u; uint hash = x * FIB_HASH; hash ^= hash >> 16; hash *= 0x85ebca6bu; hash ^= hash >> 13; hash *= 0xc2b2ae35u; hash ^= hash >> 16; return hash; }float randFibo(vec2 xy) { uint x_bits = floatBitsToUint(xy.x); uint y_bits = floatBitsToUint(xy.y); uint y_hash = fibonacciHash(y_bits); uint x_xor_y = x_bits ^ y_hash; uint final_hash = fibonacciHash(x_xor_y); return float(final_hash) / float(0xffffffffu); } out vec4 fragColor;void main() { vec2 uv = vTextureCoord; float timeRand1 = randFibo(vec2(floor(uTime * 0.5) * 2. + 0.001, 0.5)); float timeRand2 = randFibo(vec2(floor(uTime * 0.5) * 2. + 1.001, 0.5)); float sizeX = 0.5000 * 0.2 * timeRand1; float sizeY = 0.5000 * 0.2 * timeRand2; float floorY = floor(uv.y/sizeY) + 0.005; float floorX = floor(uv.x/sizeX) + 0.005; float phase = 0.0000 * 0.01; float chromab = 0.5000 * 0.75; float offset = 0.;vec2 blockSize = vec2(50.0, 50.0) * (1.0 - 0.5000); vec2 blockUV = floor(uv * blockSize) / blockSize; float blockRand = randFibo(blockUV); float blockTimeRand = timeRand1; float blockNoise = mix( 1., step(0.8, randFibo(vec2(blockTimeRand, blockRand))), 0.8000 );float offsetX = 0.5000 * 0.5 * blockNoise; float offsetY = 0.0000 * 0.5 * blockNoise;float randY = randFibo(vec2(sin(floorY + offset + phase), 0.5)); float randX = randFibo(vec2(cos(floorX + offset + phase), 0.5)); float glitchModX = max(0.005, sign(randY - 0.5 - (1. - 0.5000*2.)/2.)); float glitchModY = max(0.005, sign(randX - 0.5 - (1. - 0.5000*2.)/2.));float randOffX = randFibo(vec2(floorY + offset * glitchModX + phase, 0.7)); float randOffY = randFibo(vec2(floorX + offset * glitchModY + phase, 0.9)); float offX = (randOffX * offsetX - offsetX/2.)/5.; float offY = (randOffY * offsetY - offsetY/2.)/5.;offX = clamp(offX, -1.0, 1.0); offY = clamp(offY, -1.0, 1.0);uv.x = mix(uv.x, uv.x + offX * 2., glitchModX); uv.y = mix(uv.y, uv.y + offY * 2., glitchModY);float waveFreq = 30.0; float waveAmp = 0.005 * 0.2000; float timeOffset = uTime * 0.05; float sinY = sin((uv.y + 0.0000) * waveFreq * (1. - 0.5000) * 2. + timeOffset); float rogue = smoothstep(0., 2., sinY - 0.5) * 0.2 * 0.2000; float sinWaveX = sin(uv.y * waveFreq + uTime); float sinWaveY = sin(uv.x * waveFreq + uTime); uv.x += sinWaveX * waveAmp + rogue; uv.y += sinWaveY * waveAmp; float waveX = sinWaveX * waveAmp + rogue * chromab * 0.2;uv = clamp(uv, vec2(0.005), vec2(0.995));vec4 color = texture(uTexture, uv);vec2 redOffset = vec2( clamp(uv.x + (glitchModX * -offX * chromab - waveX), 0.005, 0.995), clamp(uv.y + (glitchModX * -offY * chromab), 0.005, 0.995) ); vec2 blueOffset = vec2( clamp(uv.x + (glitchModX * offX * chromab + waveX), 0.005, 0.995), clamp(uv.y + (glitchModX * offY * chromab), 0.005, 0.995) );color.r = texture(uTexture, redOffset).r; color.b = texture(uTexture, blueOffset).b; fragColor = color;}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "depth": false, "uniforms": {}, "isBackground": false },
      "id": "effect3"
    },
    {
      "breakpoints": [],
      "visible": true,
      "locked": false,
      "aspectRatio": 1.0636042402826855,
      "layerName": "",
      "userDownsample": 0.75,
      "isElement": true,
      "opacity": 1,
      "effects": [
        "c12993ab-36f5-49fe-8cb0-6e2b7c9657ee",
        "1a633ff0-5479-4ba4-8ac4-254f8ceaf913"
      ],
      "displace": 0,
      "trackMouse": 0.05,
      "anchorPoint": "bottomCenter",
      "mouseMomentum": 0.2,
      "blendMode": "NORMAL",
      "bgDisplace": 0,
      "mask": 0,
      "maskBackground": { "type": "Vec3", "_x": 0, "_y": 0, "_z": 0 },
      "maskAlpha": 0,
      "maskDepth": 0,
      "dispersion": 0,
      "axisTilt": 0.2,
      "states": {
        "appear": [],
        "scroll": [],
        "hover": [
          {
            "local": {
              "pendingChanges": {},
              "changeDebouncer": null,
              "dragSession": null
            },
            "type": "hover",
            "id": "132323f6-f3a6-4c68-bc39-999a7df1fcd7",
            "prop": "opacity",
            "transition": { "duration": 1, "ease": "linear", "delay": 0 },
            "progress": 0,
            "rawProgress": 0,
            "lastProgress": null,
            "value": 0,
            "triggerOnElement": 1,
            "breakpoints": ["Desktop"],
            "uniformData": { "type": "1f", "name": "uOpacity" }
          }
        ]
      },
      "layerType": "image",
      "imageLoaded": false,
      "width": 669,
      "widthMode": "fixed",
      "height": 628.9933554817276,
      "heightMode": "auto",
      "left": 0.5,
      "leftMode": "relative",
      "top": 1.000144978397517,
      "topMode": "relative",
      "rotation": 0,
      "fitToCanvas": 0,
      "src": "https://firebasestorage.googleapis.com/v0/b/unicorn-studio.appspot.com/o/tmD7AMrbJwdp7i0lgfcHfHp7grt2%2FProfile_large-removebg%201.png?alt=media&token=f5eecd12-a2a2-4fd3-8ac2-4ce279fb877e",
      "naturalWidth": 903,
      "naturalHeight": 849,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; uniform float uOpacity; uniform int uSampleBg;vec2 perspectiveUV(vec2 uv) { float aspectRatio = uResolution.x/uResolution.y; vec2 centeredUV = uv - 0.5; centeredUV.x *= aspectRatio; float strength = 1.0 + (vVertexPosition.z * 0.2000); vec2 perspectiveUV = centeredUV / strength; perspectiveUV.x /= aspectRatio; perspectiveUV += 0.5; return perspectiveUV; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.0500);uv = perspectiveUV(uv) - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color / max(color.a, 0.0001), color.a * uOpacity);fragColor = color; }"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "uniforms": {} },
      "id": "image"
    },
    {
      "breakpoints": [
        {
          "min": 992,
          "props": { "top": 1, "anchorPoint": "bottomCenter", "left": 0.5 },
          "max": null,
          "name": "Desktop"
        },
        {
          "max": 575,
          "min": 0,
          "props": { "anchorPoint": "bottomCenter", "top": 1, "left": 0.5 },
          "name": "Mobile"
        }
      ],
      "visible": true,
      "locked": false,
      "aspectRatio": 1.0636042402826855,
      "layerName": "Image 1",
      "userDownsample": 0.75,
      "isElement": true,
      "opacity": 0,
      "effects": [
        "8479c7f3-d927-4427-945b-21d26758119b",
        "2cd00530-6d8b-4ec4-b9c3-01ba5d46ddd5"
      ],
      "displace": 0,
      "trackMouse": 0.05,
      "anchorPoint": "bottomCenter",
      "mouseMomentum": 0.2,
      "blendMode": "NORMAL",
      "bgDisplace": 0,
      "mask": 0,
      "maskBackground": { "type": "Vec3", "_x": 0, "_y": 0, "_z": 0 },
      "maskAlpha": 0,
      "maskDepth": 0,
      "dispersion": 0,
      "axisTilt": 0.2,
      "states": {
        "appear": [],
        "scroll": [],
        "hover": [
          {
            "local": {
              "pendingChanges": {},
              "changeDebouncer": null,
              "dragSession": null
            },
            "type": "hover",
            "id": "e4f6c1d5-c980-4adc-bfce-39eb90eb5005",
            "prop": "opacity",
            "transition": { "ease": "linear", "duration": 1, "delay": 0 },
            "progress": 0,
            "rawProgress": 0,
            "lastProgress": null,
            "value": 1,
            "triggerOnElement": 1,
            "breakpoints": ["Desktop"],
            "uniformData": { "type": "1f", "name": "uOpacity" }
          }
        ]
      },
      "layerType": "image",
      "imageLoaded": false,
      "width": 669,
      "widthMode": "fixed",
      "height": 628.9933554817276,
      "heightMode": "auto",
      "left": 0.5,
      "leftMode": "relative",
      "top": 1,
      "topMode": "relative",
      "rotation": 0,
      "fitToCanvas": 0,
      "src": "https://firebasestorage.googleapis.com/v0/b/unicorn-studio.appspot.com/o/tmD7AMrbJwdp7i0lgfcHfHp7grt2%2FProfile_large-removebg%201.png?alt=media&token=f5eecd12-a2a2-4fd3-8ac2-4ce279fb877e",
      "naturalWidth": 903,
      "naturalHeight": 849,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; uniform float uOpacity; uniform int uSampleBg;vec2 perspectiveUV(vec2 uv) { float aspectRatio = uResolution.x/uResolution.y; vec2 centeredUV = uv - 0.5; centeredUV.x *= aspectRatio; float strength = 1.0 + (vVertexPosition.z * 0.2000); vec2 perspectiveUV = centeredUV / strength; perspectiveUV.x /= aspectRatio; perspectiveUV += 0.5; return perspectiveUV; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.0500);uv = perspectiveUV(uv) - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color / max(color.a, 0.0001), color.a * uOpacity);fragColor = color; }"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "uniforms": {} },
      "id": "image1"
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "grain",
      "usesPingPong": false,
      "speed": 0.5,
      "texture": false,
      "parentLayer": "1a633ff0-5479-4ba4-8ac4-254f8ceaf913",
      "animating": true,
      "mouseMomentum": 0,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime; uniform vec2 uResolution; uint fibonacciHash(uint x) { const uint FIB_HASH = 2654435769u; uint hash = x * FIB_HASH; hash ^= hash >> 16; hash *= 0x85ebca6bu; hash ^= hash >> 13; hash *= 0xc2b2ae35u; hash ^= hash >> 16; return hash; }float randFibo(vec2 xy) { uint x_bits = floatBitsToUint(xy.x); uint y_bits = floatBitsToUint(xy.y); uint y_hash = fibonacciHash(y_bits); uint x_xor_y = x_bits ^ y_hash; uint final_hash = fibonacciHash(x_xor_y); return float(final_hash) / float(0xffffffffu); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv);if(color.a == 0.) { fragColor = vec4(0); return; }vec2 st = uv; vec3 grainRGB = vec3(0);st *= uResolution;float delta = fract((floor(uTime)/20.));if(0 == 1) { grainRGB = vec3( randFibo(st + vec2(1, 2) + delta), randFibo(st + vec2(2, 3) + delta), randFibo(st + vec2(3, 4) + delta) ); } else { grainRGB = vec3(randFibo(st + vec2(delta))); } color.rgb = grainRGB; fragColor = color;}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "depth": false, "uniforms": {}, "isBackground": false },
      "id": "effect4"
    },
    {
      "breakpoints": [],
      "visible": true,
      "aspectRatio": 1,
      "userDownsample": 1,
      "layerType": "effect",
      "type": "grain",
      "usesPingPong": false,
      "speed": 0.5,
      "texture": false,
      "parentLayer": "2cd00530-6d8b-4ec4-b9c3-01ba5d46ddd5",
      "animating": false,
      "mouseMomentum": 0,
      "isMask": 0,
      "compiledFragmentShaders": [
        "#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return src + dst; } uint fibonacciHash(uint x) { const uint FIB_HASH = 2654435769u; uint hash = x * FIB_HASH; hash ^= hash >> 16; hash *= 0x85ebca6bu; hash ^= hash >> 13; hash *= 0xc2b2ae35u; hash ^= hash >> 16; return hash; }float randFibo(vec2 xy) { uint x_bits = floatBitsToUint(xy.x); uint y_bits = floatBitsToUint(xy.y); uint y_hash = fibonacciHash(y_bits); uint x_xor_y = x_bits ^ y_hash; uint final_hash = fibonacciHash(x_xor_y); return float(final_hash) / float(0xffffffffu); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv);if(color.a == 0.) { fragColor = vec4(0); return; }vec2 st = uv; vec3 grainRGB = vec3(0);st *= uResolution;float delta = fract((floor(uTime)/20.));if(0 == 1) { grainRGB = vec3( randFibo(st + vec2(1, 2) + delta), randFibo(st + vec2(2, 3) + delta), randFibo(st + vec2(3, 4) + delta) ); } else { grainRGB = vec3(randFibo(st + vec2(delta))); } color.rgb = mix(color.rgb, blend(1, grainRGB, color.rgb), 0.5000); fragColor = color;}"
      ],
      "compiledVertexShaders": [
        "#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"
      ],
      "data": { "depth": false, "uniforms": {}, "isBackground": false },
      "id": "effect5"
    }
  ],
  "options": {
    "name": "Hero Portfolio",
    "fps": 60,
    "dpi": 1.5,
    "scale": 1,
    "includeLogo": false,
    "isProduction": true
  },
  "version": "1.4.29",
  "id": "n50wRZRCNWWhQCsXC1kq"
}
